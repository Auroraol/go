 **Go单元测试**

```go
import (
	"testing"
)

func TestSendTalos(t *testing.T) {
	
}
```



[21. go单元测试工具之mockey与convey_mockey用法-CSDN博客](https://blog.csdn.net/YouMing_Li/article/details/133709601)

[使用 gomonkey 遇到非 debug 模式执行失败的问题及解决方法-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2014830)



[21. go单元测试工具之mockey与convey_mockey用法-CSDN博客](https://blog.csdn.net/YouMing_Li/article/details/133709601)

![image-20240929222429439](%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/image-20240929222429439.png)

测试整个文件：

```shell
16658@Vicissitudes MINGW64 /c/PCTMoveData/Desktop/Browser Download/code/src/github.com/davyxu/golog
$ go test -v log_test.go log.go level.go color.go log_windows.go manager.go 
=== RUN   TestLevel
[DEBUG] test 2024/09/29 21:57:31 1 hello world
[ERROR] test 2024/09/29 21:57:31 hello1
[ERROR] test 2024/09/29 21:57:31 2
[INFO] test 2024/09/29 21:57:31 no
--- PASS: TestLevel (0.01s)
[ERROR] test 2024/09/29 21:57:31 2
[INFO] test 2024/09/29 21:57:31 no
--- PASS: TestLevel (0.01s)
=== RUN   TestMyLog
=== RUN   TestMyLog
[DEBUG] test2 2024/09/29 21:57:31 hello1
[DEBUG] test2 2024/09/29 21:57:31 hello2
[DEBUG] test2 2024/09/29 21:57:31 hello3
--- PASS: TestMyLog (0.00s)
=== RUN   TestSystemLog
2024/09/29 21:57:31 hello1
2024/09/29 21:57:31 hello2
2024/09/29 21:57:31 hello3
--- PASS: TestSystemLog (0.00s)
PASS
ok      command-line-arguments  0.195s
```

测试单个函数：

```shell
16658@Vicissitudes MINGW64 /c/PCTMoveData/Desktop/Browser Download/code/src/github.com/davyxu/golog
$ go test -v log_test.go log.go level.go color.go log_windows.go manager.go -test.run TestSystemLog
=== RUN   TestSystemLog
2024/09/29 21:59:58 hello1
2024/09/29 21:59:58 hello2
2024/09/29 21:59:58 hello3
--- PASS: TestSystemLog (0.01s)
PASS
ok      command-line-arguments  0.216s
```

## mock

> 在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。

### 1. 开始mock

**API**：Mock(target interface{}) *MockBuilder
参数：target 需要mock的函数
返回：`*MockBuilder`
**参考实例：**

```go
func Fun(a string) string {
   fmt.Println(a)
   return a
}

type Class struct {
}

func (*Class) FunA(a string) string {
   fmt.Println(a)
   return a
}

func TestMock(t *testing.T) {
    Mock(Fun)                //对于普通函数使用这种
    Mock((*Class).FunA)      //对于class(struct)使用这种方式
}
```

### 2. 条件设置 （可选）

**API**：When(when interface{}) *MockBuilder
**参数**：when 函数指针。表示在何种条件下调用mock函数返回mock结果。
**函数原型**： when(args…) bool

```
args：与Mock 函数参数一致，一般通过args来判断是否需要执行 mock，注意类成员函数需要增加self作为第一个参数（目前已经兼容了不传入receiver，当不需要使用的时候可以忽略）
返回值： bool ，是true的时候执行 mock
```

**返回**： `*MockBuilder`
**参考实例**

```go
 func TestMock(t *testing.T) {
    //对于普通函数使用这种
    Mock(Fun).When(func(p string) bool { return p == "a" })                
    //对于class使用这种方式
    Mock((*Class).FunA).When(func(self *Class, p string) bool { return p == "a" })   
}
```

### 3. 结果设置

####  mock方式一：直接设置结果

**API**：Return(results …interface{}) *MockBuilder
**参数**: results 参数列表需要完全等同于需要mock的函数返回值列表,（mockey v1.2.4+新增sequence支持，可以设置多个连续的返回值）
**返回**： `*MockBuilder`
**参考实例**：

```go
Mock(Fun).Return("c").Build()

// mockey v1.2.4+ 支持
Mock(Fun).Return(Sequence("Alice").Times(3).Then("Bob").Then("Tom").Times(2)).Build()
```

#### mock方式二：使用mock函数

**API**：To(hook interface{}) *MockBuilder
**参数**: hook 参数与返回值需要与mock函数完全一致，`注意类成员函数需要增加self作为第一个参数（目前已经兼容了不传入receiver，当不需要使用的时候可以忽略）`
**返回**： mockBuilder
**参考实例**：`原调用Fun函数的地方替换为调用mock函数，注意mock函数与Fun函数定义要一致（即入参，返回值一致）`

```go
func Fun(a string) string {
   fmt.Println(a)
   return a
}

mock := func(p string) string {
   fmt.Println("b")
   return "b"
}
Mock(Fun).To(mock).Build()
```

## 断言方法

GoConvey为我们提供了很多种类断言方法在So()函数中使用。

1. 一般相等类

  ```
  So(thing1, ShouldEqual, thing2)
  So(thing1, ShouldNotEqual, thing2)
  So(thing1, ShouldResemble, thing2)		// 用于数组、切片、map和结构体相等
  So(thing1, ShouldNotResemble, thing2)
  So(thing1, ShouldPointTo, thing2)
  So(thing1, ShouldNotPointTo, thing2)
  So(thing1, ShouldBeNil)
  So(thing1, ShouldNotBeNil)
  So(thing1, ShouldBeTrue)
  So(thing1, ShouldBeFalse)
  So(thing1, ShouldBeZeroValue)
  ```

  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  11

2. 数字数量比较类

  ```
  So(1, ShouldBeGreaterThan, 0)
  So(1, ShouldBeGreaterThanOrEqualTo, 0)
  So(1, ShouldBeLessThan, 2)
  So(1, ShouldBeLessThanOrEqualTo, 2)
  So(1.1, ShouldBeBetween, .8, 1.2)
  So(1.1, ShouldNotBeBetween, 2, 3)
  So(1.1, ShouldBeBetweenOrEqual, .9, 1.1)
  So(1.1, ShouldNotBeBetweenOrEqual, 1000, 2000)
  So(1.0, ShouldAlmostEqual, 0.99999999, .0001)   // tolerance is optional; default 0.0000000001
  So(1.0, ShouldNotAlmostEqual, 0.9, .0001)
  ```

  1
  2
  3
  4
  5
  6
  7
  8
  9
  10

3. 包含类

  ```
  So([]int{2, 4, 6}, ShouldContain, 4)
  So([]int{2, 4, 6}, ShouldNotContain, 5)
  So(4, ShouldBeIn, ...[]int{2, 4, 6})
  So(4, ShouldNotBeIn, ...[]int{1, 3, 5})
  So([]int{}, ShouldBeEmpty)
  So([]int{1}, ShouldNotBeEmpty)
  So(map[string]string{"a": "b"}, ShouldContainKey, "a")
  So(map[string]string{"a": "b"}, ShouldNotContainKey, "b")
  So(map[string]string{"a": "b"}, ShouldNotBeEmpty)
  So(map[string]string{}, ShouldBeEmpty)
  So(map[string]string{"a": "b"}, ShouldHaveLength, 1) // supports map, slice, chan, and stri
  ```

  ng
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  11

4. 字符串类

  ```
  So("asdf", ShouldStartWith, "as")
  So("asdf", ShouldNotStartWith, "df")
  So("asdf", ShouldEndWith, "df")
  So("asdf", ShouldNotEndWith, "df")
  So("asdf", ShouldContainSubstring, "稍等一下")		// optional 'expected occurences' arguments?
  So("asdf", ShouldNotContainSubstring, "er")
  So("adsf", ShouldBeBlank)
  So("asdf", ShouldNotBeBlank)
  ```

  1
  2
  3
  4
  5
  6
  7
  8

5. panic类

  ```
  So(func(), ShouldPanic)
  So(func(), ShouldNotPanic)
  So(func(), ShouldPanicWith, "")		// or errors.New("something")
  So(func(), ShouldNotPanicWith, "")	// or errors.New("something")
  ```

  1
  2
  3
  4

6. 类型检查类

  ```
  So(1, ShouldHaveSameTypeAs, 0)
  So(1, ShouldNotHaveSameTypeAs, "asdf")
  ```

  1
  2

7. 时间和时间间隔类

  ```
  So(time.Now(), ShouldHappenBefore, time.Now())
  So(time.Now(), ShouldHappenOnOrBefore, time.Now())
  So(time.Now(), ShouldHappenAfter, time.Now())
  So(time.Now(), ShouldHappenOnOrAfter, time.Now())
  So(time.Now(), ShouldHappenBetween, time.Now(), time.Now())
  So(time.Now(), ShouldHappenOnOrBetween, time.Now(), time.Now())
  So(time.Now(), ShouldNotHappenOnOrBetween, time.Now(), time.Now())
  So(time.Now(), ShouldHappenWithin, duration, time.Now())
  So(time.Now(), ShouldNotHappenWithin, duration, time.Now())
  ```

  1
  2
  3
  4
  5
  6
  7
  8
  9

8. 自定义断言方法
如果上面列出来的断言方法都不能满足你的需要，那么你还可以按照下面的格式自定义一个断言方法。

注意：<>中的内容是你需要按照实际需求替换的内容。

```
func should<do-something>(actual interface{}, expected ...interface{}) string {
    if <some-important-condition-is-met(actual, expected)> {
        return ""   // 返回空字符串表示断言通过
    }
    return "<一些描述性消息详细说明断言失败的原因...>"
}
```

## 案例

### 普通函数

```cobol
package test
 
import (
   . "github.com/bytedance/mockey"
   . "github.com/smartystreets/goconvey/convey"
   "testing"
)
 
func funcA(s string) string {
   return s
}
 
// go test -run TestMockFunc -v -gcflags="all=-l -N"
// 使用-gcflags="all=-l -N"，禁用内联和编译优化
func TestMockFunc(t *testing.T) {
   PatchConvey("mock函数方式1", t, func() {
      Mock(funcA).Return("mock s").Build()
      So(funcA("hello"), ShouldEqual, "mock s")
   })
 
   PatchConvey("mock函数方式2", t, func() {
      Mock(funcA).To(func(s string) string {
         return "mock s"
      }).Build()
      So(funcA("hello"), ShouldEqual, "mock s")
   })
 
   PatchConvey("mock函数，使用when来决定是否需要mock", t, func() {
      Mock(funcA).When(func(s string) bool {
         return s == "hello1"
      }).To(func(s string) string {
         return "mock s"
      }).Build()
      So(funcA("hello1"), ShouldEqual, "mock s")
      So(funcA("hello"), ShouldEqual, "mock s")
   })
 
   PatchConvey("mock函数，手动取消mock，手动再次mock", t, func() {
      m := Mock(funcA).To(func(s string) string {
         return "mock s"
      }).Build()
      m.IncludeCurrentGoRoutine()
      So(funcA("hello"), ShouldEqual, "mock s")
      So(m.Times(), ShouldEqual, 1)
      So(m.MockTimes(), ShouldEqual, 1)
 
      // 手动取消
      m.UnPatch()
      So(funcA("hello"), ShouldEqual, "hello")
 
      // 手动再次mock
      m.Patch()
      So(funcA("hello"), ShouldEqual, "mock s")
   })
}

```

进入到当前文件所在目录后，命令行输入：go test -run TestMockFunc -v -gcflags="all=-l -N"，单元测试结果如下：

```cobol
=== RUN   TestMockFunc
 
  mock函数方式1 ✔
 
 
1 total assertion
 
 
  mock函数方式2 ✔
 
 
2 total assertions
 
 
  mock函数，使用when来决定是否需要mock ✔✘
 
 
Failures:
 
  * xxx/framework/all/test2/mockey_test.go 
  Line 78:
  Expected: "mock s"
  Actual:   "hello"
  (Should equal)!
 
 
4 total assertions
 
 
  mock函数，手动取消mock，手动再次mock ✔✔✔✔✔
 
 
9 total assertions
 
--- FAIL: TestMockFunc (0.00s)
FAIL
exit status 1
FAIL    xxx/framework/all/test2    2.087s
```

### 结构体

```cobol
package test
 
import (
   . "github.com/bytedance/mockey"
   . "github.com/smartystreets/goconvey/convey"
   "testing"
)
 
type Class struct {
}
 
func (Class) FunA(s string) string {
   return s
}
 
func (*Class) FunB(s string) string {
   return s
}
 
// go test -run TestMockMethod -v -gcflags="all=-l -N"
func TestMockMethod(t *testing.T) {
   PatchConvey("mock方法方式1", t, func() {
      PatchConvey("mock方法方式1.1 - 非指针", func() {
         Mock(Class.FunA).Return("mock s").Build()
         So(Class{}.FunA("hello"), ShouldEqual, "mock s")
      })
      PatchConvey("mock方法方式1.2 - 指针", func() {
         Mock((*Class).FunB).Return("mock s").Build()
         So((&Class{}).FunB("hello"), ShouldEqual, "mock s")
      })
   })
 
   PatchConvey("mock方法方式2", t, func() {
      PatchConvey("mock方法方式2.1 - 非指针", func() {
         Mock(Class.FunA).To(func(self Class, s string) string {
            return "mock s"
         }).Build()
         So(Class{}.FunA("hello"), ShouldEqual, "mock s")
      })
      PatchConvey("mock方法方式2.2 - 指针", func() {
         Mock((*Class).FunB).To(func(self *Class, s string) string {
            return "mock s"
         }).Build()
         So((&Class{}).FunB("hello"), ShouldEqual, "mock s")
      })
   })
}
```

进入到当前文件所在目录后，命令行输入：go test -run TestMockMethod -v -gcflags="all=-l -N"，单元测试结果如下：

```cobol
=== RUN   TestMockMethod
 
  mock方法方式1 
    mock方法方式1.1 - 非指针 ✔
    mock方法方式1.2 - 指针 ✔
 
 
2 total assertions
 
 
  mock方法方式2 
    mock方法方式2.1 - 非指针 ✔
    mock方法方式2.2 - 指针 ✔
 
 
4 total assertions
 
--- PASS: TestMockMethod (0.00s)
PASS
ok      xxx/framework/all/test2    1.400s
```

工具函数
// 作用：mock私有类型的方法 或 mock匿名struct的方法，获取不到会panic
// 参数：
// instance：私有struct实例 或 含有多层嵌套匿名struct的struct实例
// methodName：对应方法名，必须是public方法
func GetMethod(instance interface{}, methodName string) interface{}
// 获取当前goroutine id，已过时，不推荐使用

```go
package test
 
import (
   "fmt"
   . "github.com/bytedance/mockey"
   . "github.com/smartystreets/goconvey/convey"
   "testing"
)
 
type IReader interface {
   Get(key string) string
}
 
type reader struct {
   *Client1
}
 
func (r *reader) Get(s string) string {
   return r.Client1.GetKey(s)
}
 
func NewReader(c *Client1) IReader {
   return &reader{
      Client1: c,
   }
}
 
type Client1 struct {
   client2
}
 
type client2 struct {
}
 
func (c *client2) GetKey(key string) string {
   return key
}
 
// go test -run TestGetMethod -v -gcflags="all=-l -N"
func TestGetMethod(t *testing.T) {
   PatchConvey("工具类", t, func() {
      PatchConvey("使用GetMethod mock私有类型的方法", func() {
         r := NewReader(nil)
         Mock(GetMethod(r, "Get")).To(func(s string) string {
            return "aaa"
         }).Build()
         fmt.Println(r.Get(""))
      })
 
      PatchConvey("使用GetMethod mock匿名struct的方法", func() {
         r := NewReader(&Client1{})
         Mock(GetMethod(r, "GetKey")).To(func(s string) string {
            return "bbb"
         }).Build()
         fmt.Println(r.Get(""))
      })
 
      PatchConvey("GetGoroutineId获取当前goroutine id", func() {
         fmt.Println(GetGoroutineId())
      })
   })
}
```

进入到当前文件所在目录后，命令行输入：go test -run TestGetMethod -v -gcflags="all=-l -N"，单元测试结果如下：

    === RUN   TestGetMethod
     
      工具类 
        使用GetMethod mock私有类型的成员函数 aaa
     
        使用GetMethod mock匿名struct的成员函数 bbb
     
        GetGoroutineId获取当前goroutine id 6
     
     
     
    0 total assertions
     
    --- PASS: TestGetMethod (0.00s)
    PASS
    ok      xxx/framework/all/test2    0.613s

 

三、WebUI
goconvey提供全自动的WebUI。

安装
如果需要使用goconvey的Web UI程序，请执行下面的命令安装可执行程序。

 go install github.com/smartystreets/goconvey@latest
1
安装完成后在项目目录下执行以下命令

goconvey
1
默认就会在本机的8080端口提供WebUI界面，十分清晰地展现当前项目的单元测试数据。

![在这里插入图片描述](%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/ff31cdf56a9ba8b76951b5cdd42a56b5.png)