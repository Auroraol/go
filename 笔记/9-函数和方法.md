# t函数和方法

## 函数

### 定义函数

```go
func function_name( [parameter list] ) [return_types] {
   函数体
}
```

+ func：声明这是一个函数

+ function_name：函数名称，函数名和参数列表一起构成了函数签名

  + 函数名使用  公有(`MixedCaps` ) or 私有( `mixedCaps`)

  + 对相关的测试用例进行分组，函数名可能包含下划线，如：`TestMyFunction_WhatIsBeingTested`.

+ parameter list：参数列表，注意类型在变量名之后

+ return_types：返回类型，不是必须的，当没有返回值时，可以不指定返回类型，也可以返回多个值，如(string,string)

+ 函数体：函数定义的代码集合　　　

### **init函数和mian函数**

**init函数：**init 函数可在package main中，可在其他package中，可在同一个package中出现多次。

**main函数:**  main 函数只能在package main中

**执行顺序**

1. 程序的初始化和执行都起始于main包(注意是main包,不是面函数)
2. <span style="color:green">先按包的顺序依次自动执行他们的init函数</span>
3. 再执行main包init函数, 然后继续执行main函数
3. ![image-20240927102908301](%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95.assets/image-20240927102908301.png)

![image-20240922181201161](%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95.assets/image-20240922181201161.png)

**示例:**

Lib1.go

```go
package InitLib1

import "fmt"

func init() {
    fmt.Println("lib1")
}
```

Lib2.go

```go
package InitLib2

import "fmt"

func init() {
    fmt.Println("lib2")
}
```

main.go

```go
package main

import (
    "fmt"
	_"GolangStudy/5-init/lib1"
	_"GolangStudy/5-init/lib2"
)

func init() {
    fmt.Println("libmain init")
}

func main() {
    fmt.Println("libmian main")
}
```

运行结果

```
lib1
lib2
libmain init
libmian main
```

改动一个地方，Lib1包导入Lib2，main包不管

```go
package InitLib1

import (
    "fmt"
    _ "GolangTraining/InitLib2"
)

func init() {
    fmt.Println("lib1")
}
```

运行结果

```
lib2
lib1
libmain init
libmian main
```

### 常用函数用法

**注意：**

①：Go函数不支持重载

②：一个包中不能有两个名字一样的函数

③：当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他的类型可以省略

④：函数可以返回任意数量的返回值

⑤：使用关键字 func 定义函数，左大括号依旧不能另起一行

```go
// 函数多参无返回值
func func_name(a,b int, c string){}
// 函数无参无返回值
func func_name(){}
// 单个返回值
func func_name(s string) string{}
// 多个返回值
func func_name (s string) (string,int){}
// 命名返回参数
func func_name(s string) (result string){
    ...
    result=1
    return
}
// 可变参数，可变参数只能做为函数参数存在，并且是最后一个参数，本质上是slice
func func_name(s string,args ...int){}

// 匿名函数，调用：f(1,2)
f := func(x,y int) int {
    return x + y
}
```

#### 一、闭包

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。

匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

**示例:**

```go
var x int
inc := func() int {
    x++
    return x
}

fmt.Println(func() (a, b int) {
    return inc(), inc()
}())
```

**示例:**

```go
// 创建函数a，返回另外一个函数。
//该函数的目的是在闭包中递增i的变量
func a() func() int {
    i := 0
    b := func() int {
        i++
        fmt.Println(i)
        return i
    }
    return b
}

func main() {
    c := a()
    c() // 1
    c() // 2
    c() // 3

    a() //不会输出i
}
```

#### 二、可变长度的参数

使用 ... 指定参数的长度是可变的。

```go
var Test = func(values...int)  {
    for _, v := range values {
        fmt.Println(v)
    }
}

Test(1,2,3)
```

#### 三、立即执行的函数

跟JS类似，go中也可以让函数立即执行，并且不需要像JS一样在函数之前添加 ; 

```go
func(values...int)  {
    for _, v := range values {
        fmt.Println(v)
    }
}(1,2,3)
```

```
1
2
3
```

#### 四、返回多个值的函数

```go
package main

import "fmt"

//返回单个返回值，匿名的
func foo1(a string, b int) int {
	fmt.Println("a = ", a)
	fmt.Println("b = ", b)
	c := 100
	return c
}

//返回多个返回值，匿名的
func foo2(a string, b int) (int, int) {
	fmt.Println("a = ", a)
	fmt.Println("b = ", b)

	return 666, 777
}

//返回多个返回值， 有形参名称的
//func foo3(a string, b int) (r1, r2 int) 或者
func foo3(a string, b int) (r1 int, r2 int) {
	fmt.Println("---- foo3 ----")
	fmt.Println("a = ", a)
	fmt.Println("b = ", b)

	//r1 r2 属于foo3的形参，  初始化默认的值是0
	//r1 r2 作用域空间 是foo3 整个函数体的{}空间
	fmt.Println("r1 = ", r1)
	fmt.Println("r2 = ", r2)

	//给有名称的返回值变量赋值
	r1 = 1000
	r2 = 2000

	return
}

func main() {
	c := foo1("abc", 555)
	fmt.Println("c = ", c)

	ret1, ret2 := foo2("haha", 999)
	fmt.Println("ret1 = ", ret1, " ret2 = ", ret2)

	ret1, ret2 = foo3("foo3", 333)
	fmt.Println("ret1 = ", ret1, " ret2 = ", ret2)
}

// ---- foo1 ----
// a =  abc
// b =  555
// c =  100
// ---- foo2 ----
// a =  haha
// b =  999
// ret1 =  666  ret2 =  777
// ---- foo3 ----
// a =  foo3
// b =  333
// r1 =  0
// r2 =  0
// ret1 =  1000  ret2 =  2000
```

#### 五、值传递与引用传递

**按值传递**

```go
func swap(x int, y int) {
	var temp int

	temp = x
	x = y
	y = temp
}

func main() {
	/* 定义局部变量 */
	var a int = 100
	var b int = 200
	fmt.Printf("交换前 a 的值为 : %d\n", a ) // 100
	fmt.Printf("交换前 b 的值为 : %d\n", b ) // 200

	/* 通过调用函数来交换值 */
	swap(a, b)
	fmt.Printf("交换后 a 的值 : %d\n", a ) // 100
	fmt.Printf("交换后 b 的值 : %d\n", b ) // 200
}
```

程序中使用的是值传递，所以两个值并没有实现交换。

**使用引用的示例：**(类似c++中的按指针传递)

```go
func swap(x *int, y *int) {
	var temp int

	temp = *x
	*x = *y
	*y = temp
}

func main() {
	/* 定义局部变量 */
	var a int = 100
	var b int = 200
	fmt.Printf("交换前 a 的值为 : %d\n", a ) // 100
	fmt.Printf("交换前 b 的值为 : %d\n", b ) // 200

	/* 通过调用函数来交换值 */
	swap(&a, &b)
	fmt.Printf("交换后 a 的值 : %d\n", a ) // 200
	fmt.Printf("交换后 b 的值 : %d\n", b ) // 100
}
```

由于传递的是引用，指向内存地址，所有值成功交换了。

#### 六、延迟语句

使用 defer 关键字可以使函数中的某一条语句延迟执行，也就是在<span style="color:red">函数结束的时候才执行</span>

defer作用：

+ 释放占用的资源(锁和文件)
+ 捕捉处理异常
+ 输出日志

##### 基本使用

| **Bad**                                                      | **Good**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `p.Lock() if p.count < 10 {  p.Unlock()  return p.count } p.count++ newCount := p.count p.Unlock() return newCount // 当有多个 return 分支时，很容易遗忘 unlock` | `p.Lock() defer p.Unlock() if p.count < 10 {  return p.count } p.count++ return p.count // 更可读` |

比如在读写文件时，可以将关闭文件写在前面，以防止遗忘关闭文件的操作：

```go
func readFile(path string) ([]byte, error) {
    file, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    return ioutil.ReadAll(file)
}
```

如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。

```go
package main

import "fmt"

func main() {
	//写入defer关键字
	defer fmt.Println("main end1")
	defer fmt.Println("main end2")


	fmt.Println("main::hello go 1")
	fmt.Println("main::hello go 2")
}
```

![image-20231114202523826](%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95.assets/image-20231114202523826.png)

##### defer匿名函数

当一个函数中存在多个defer语句时，可以将其放置于匿名函数中，它们携带的表达式语句的执行顺序一定是它们的出现顺序的倒序。

```go
func main() {
	fmt.Println(1)
	defer func() {
		fmt.Println(2)
		fmt.Println(3)
	}()
	fmt.Println("end")
}
```

##### 循环之中的defer

当defer放于循环之中，其输出值将反向输出。

```go
func main() {
	f := func(i int) int {
		fmt.Printf("%d ",i)
		return i * 10
	}
	for i := 1; i < 5; i++ {
		defer fmt.Printf("%d ", f(i))
	}
}
```

输出：

```
1 2 3 4 40 30 20 10
```

##### 循环中defer匿名函数

当在循环中defer的是一个匿名函数，那么其输出值将会是最终循环值。

```go
for i := 1; i < 5; i++ {
    defer func() {
        fmt.Print(i)
    }()
}
```

输出

```
5555
```

原因是defer语句携带的表达式语句中的那个匿名函数包含了对外部（确切地说，是该defer语句之外）的变量的使用。注意，等到这个匿名函数要被执行（且会被执行4次）的时候，包含该defer语句的那条for语句已经执行完毕了。此时的变量i的值已经变为了5。因此该匿名函数中的打印函数只会打印出5。

正确的用法是：把要使用的外部变量作为参数传入到匿名函数中。（玩过JS的一定都懂）

```go
for i := 1; i < 5; i++ {
    defer func(n int) {
        fmt.Print(n)
    }(i)
}
```

##### recover错误拦截

运行时panic异常一旦被引发就会导致程序崩溃。

Go语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。


注意：recover只有在defer调用的函数中有效。

```go
package main

import "fmt"

func Demo(i int) {
	//定义10个元素的数组
	var arr [10]int
    
     // 捕获处理panic
	//错误拦截要在产生错误前设置
	defer func() {
		//设置recover拦截错误信息
		err := recover()
		//产生panic异常  打印错误信息
		if err != nil {
			fmt.Println(err)
		}
	}()
    
    // 触发panic
	//根据函数参数为数组元素赋值
	//如果i的值超过数组下标 会报错误：数组下标越界
	arr[i] = 10

}

func main() {
	Demo(10)
	//产生错误后 程序继续
	fmt.Println("程序继续执行...")
}
```

运行结果

```
runtime error: index out of range
程序继续执行...
```



#### 七、递归函数

阶乘

```go
func Factorial(n uint64)(result uint64) {
	if n > 0 {
		result = n * Factorial(n-1)
		return result
	}
	return 1
}

func main() {
	var i int = 5
	fmt.Printf("%d 的阶乘是 %d\n", i, Factorial(uint64(i)))
}
```

**斐波那契数列**

```go
func fibonacci(n int) int {
	if n < 2 {
		return n
	}
	return fibonacci(n-2) + fibonacci(n-1)
}

func main() {
	var i int
	for i = 0; i < 10; i++ {
		fmt.Printf("%d\t", fibonacci(i))
	}
}
```

#### 八、匿名函数

匿名函数的优越性在于可以直接使用函数内的变量，不必声明

Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。

```go
getSqrt := func(a float64) float64 {
    return math.Sqrt(a)
}

fmt.Println(getSqrt(4))
```

#### 九、函数表达式

使用函数表达式实现三目运算

```go
// 函数表达式,实现三目运算
// 格式：func() returnType {...}()
i := 1
j := 2
k := func() int {
    if i > j {
        return i
    }
    return j
}()
fmt.Println(k)
```

带参数的函数表达式：

```go
h := func(a, b int) int {
    if a > b {
        return a
    }
    return b
}(i, j)
```

## 方法

### 基础知识

Go 语言中同时有函数和方法。<span style="color:red">一个方法就是一个包含了接收者的函数。</span>方法可以将类型和方法封装在一起，实现强耦合。

接收者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集<span style="color:red">**接收者可以理解为当前的对象，即方法所在类型的对象，可以理解为结构体的方法，类似于Java中的this，显式的声明了出来**</span>

**结构体方法的定义格式如下：**

```go
func (接收者变量 接收者类型) 方法名(参数列表) (返回类型) {
	方法体
}
```

规则 

- 值对象只可以使用值接收器方法集
- 指针对象可以使用 值接收器方法集 + 指针接收器方法集

什么时候应该使用指针类型接收者:

①：需要修改接收者中的值

②：接收者是拷贝代价比较大的大对象

③：保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者'

```go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

sVals := map[int]S{1: {"A"}}

// 你只能通过值调用 Read
sVals[1].Read()

// 这不能编译通过：
//  sVals[1].Write("test")

sPtrs := map[int]*S{1: {"A"}}

// 通过指针既可以调用 Read，也可以调用 Write 方法
sPtrs[1].Read()
sPtrs[1].Write("test")
```

**示例：**

```go
package main

import (
    "fmt"
)

// 定义结构体
type User struct {
    name    string
    gender  string
    address string
    age     int
}

// 值类型的接收者
func (user User) getName() string {
    return user.name
}

// 指针类型的接收者
func (user *User) setName(name string) {
    user.name = name
    fmt.Println("Updated name:", user.getName()) // 调用 getName 方法
}

func main() {
    user := &User{
        name:    "yangyongjie",
        age:     27,
        gender:  "male",
        address: "nanjing",
    }
    
    name := user.getName() // 调用 getName 方法
    fmt.Println(name)      // 输出: yangyongjie

    user1 := &User{}
    user1.setName("yyj") // 调用 setName 方法
    fmt.Println(user1.getName()) // 输出: yyj
}
```

**值类型的接收者和值类型的接收者方法的区别：**

+ 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式十分接近于Java语言中的this，和Python语言中的self
+ 当方法作用于值类型的接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但是修改操作只是针对副本，无法修改接收者变量本身。　　　　

**示例：**

```go
import "fmt"

// 定义结构体
type User struct {
    name    string
    gender  string
    address string
    age     int
}

// 值类型的接收者
func (user User) setAddress(address string) {
    user.address = address
}

// 指针类型的接收者
func (user *User) setName(name string) {
    user.name = name
}

func main() {
    user := &User{
        name:    "yangyongjie",
        age:     27,
        gender:  "male",
        address: "nanjing",
    }
    
    // 接收值类型的方法，user变量本身值没有被修改
    user.setAddress("beijing")
    fmt.Println(user.address) // nanjing

    // 接收指针类型的方法，user变量本身值没有被修改
    user.setName("yyj")
    fmt.Println(user.name) // yyj

}
```

**补充示例：**

```go
func main() {
	person := Person{Name: "Xiaoyu", Age: 18, Sex: 1}
	person.Say("hello") // Xiaoyu say hello
}

// 声明
type Person struct {
	Name string
	Age int
	Sex int
}

func (person *Person) Say(words string) {
	fmt.Println(person.Name, "say", words)
}
```

尝试将Say换为say，发现会报错。go就是通过控制方法的大小写来控制其作用域，如果是小写只能内部调用。

### 调用

```go
package main

import "fmt"

type MyStruct struct {
    value int
}

func (m *MyStruct) Method1() {
    fmt.Println("Method1 is called")
    m.Method2()          // 调用自己的其他方法
    normalFunction()     // 调用普通函数
}

func (m *MyStruct) Method2() {
    fmt.Println("Method2 is called")
}

func normalFunction() {
    fmt.Println("This is a normal function")
}

func main() {
    myStruct := MyStruct{value: 42}
    myStruct.Method1() // 调用接收者的方法
}
```







```go
package main

import "fmt"

type MyStruct struct {
    value int
}

func (m *MyStruct) Method1() {
    fmt.Println("Method1 is called")
}

func (m MyStruct) Method() {
    fmt.Println("Method2 is called")
}


func main() {
    myStruct := MyStruct{value: 42}
    myStruct.Method1()
    myStruct.Method2()
    myStruct.Method3("Hello")
}
```



