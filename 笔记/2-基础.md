# 基础语法

### 一、输出语句

使用 fmt.Println 输出：

```go
fmt.Println("hello")
```

也可以使用 fmt.Printf 格式化输出：

```go
fmt.Println("%v %v %v %q\n", i, f, b, s)
```

输出而不换行使用：

```go
fmt.Println(10)
```

使用 println() 和 print() 也可以打印数据。

### 二、变量

```go
package main

import "fmt"

func main() {
    //同时定义多个变量：
    var name string = "xiaoyu"
    fmt.Println(name)

    var a1 int = 0
    fmt.Println(a1)

    var b1, c1 int = 1, 2
    fmt.Println(b1, c1)

    //可以将变量声明放于括号之中：
    var (
        a string = "1"
        b int = 2
        c int
    )
    fmt.Println(a, b, c)
}
```

运行结果

```go
xiaoyu
0
1 2
1 2 0
```

#### 零值

零值就是变量没有做初始化时系统默认设置的值

```go
// 数值类型（包括complex64/128）为 0
var a int
var a int8
var a int16
var a int32
var a int64
var a float32
var a float64
var a complex64 // 0+0i
var a complex128 // 0+0i

// 字符串为 ""（空字符串）
var a string

// 布尔类型为 false
var a bool

// 以下几种类型为 nil：
var a *int
var a []int
var a map[string] int
var a chan int
var a func(string) int
var a error // error 是接口
```

#### 通过 := 声明变量

可以省略 var ，使用 := 声明并为变量赋值

```go
a := 1
fmt.Print(a)       //必须是声明新的变量, 后进行变量赋值

a = 2              //只能赋值
fmt.Print(a)

nn := "mmmmm么么么么"
fmt.Println(nn)
```

同时声明多个变量：

```go
a, b := 1, 2 
println(a, b)
```

### 空白标识符

空白标识符 _ 常常被用于抛弃值，如值 5 在 _, b = 5, 7 中被抛弃。这在丢弃函数的某些返回值时非常有用。

### 三、常量

定义常量跟变量差不多，只是将关键字改为const

```go
const LENGTH int = 10
```

**iota**

iota，特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

```go
 const (
    a = iota   //0
    b          //1
    c          //2
    d = "ha"   //独立值，iota += 1
    e          //"ha"   iota += 1
    f = 100    //iota +=1
    g          //100  iota +=1
    h = iota   //7,恢复计数
    i          //8
  )
  fmt.Println(a,b,c,d,e,f,g,h,i) // 0 1 2 ha ha 100 100 7 8
```

再看一个有趣的例子：

```go
 const (
    i=1<<iota // 1: 1b; 1<<0 1b(1)
    j=3<<iota // 3: 11b; 3<<1: 110b(6)
    k // 3<<2: 1100b(12)
    l // 3<<3: 11000b(24)
  )
  fmt.Println(i,j,k,l) // 1 6 12 24
```

注：<<n==*(2^n)

### 四、关键字

下面列举了 Go 代码中会使用到的 25 个关键字或保留字：

|          |             |        |           |        |
| -------- | ----------- | ------ | --------- | ------ |
| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：

|        |         |         |         |        |         |           |            |         |
| ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |
| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |
| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |
| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |
| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |

### 五、运算符

+ 算术运算符：+ - * / % ++ --
+ 关系运算符：== != > < >= <=
+ 逻辑运算符：&& || !
+ 位运算符：& | ^ << >>
+ 赋值运算符：= += -= *= /= %= <<= >>= &= ^= |=

引用：

+ & 返回变量存储地址。示例：&a 将给出变量的实际地址。

指针：

+ 指针变量。示例：*a 是一个指针变量

**运算符优先级**

| 优先级 | 运算符           |
| ------ | ---------------- |
| 5      | * / % << >> & &^ |
| 4      | + - \| ^         |
| 3      | == != < <= > >=  |
| 2      | &&               |
| 1      | \|\|             |

# 数据类型

## 数据类型概述

**数据类型**　　　　

| 序号 | 类型和描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | **布尔型** 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |
| 2    | **数字类型** 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。Go语言中没有字符类型，字符只是整数的特殊用例。因为用于表示字符的byte和rune（字符默认类型)类型分别等于int8和int32。Go中字符用单引号（''）包围 |
| 3    | **字符串类型:** 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 字符串的值为双引号("")中的内容字符串可以使用+拼接，fmt.Sprintf 格式化字符串并赋值给新串 |
| 4    | **派生类型:** 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 |

Go 语言按类别有以下几种数据类型：

+ **布尔型**
  + 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。

+ **数字类型**
  + 整型 int、uint 和 uintptr 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。
  + uint：32 或 64 位
  + uint8：无符号 8 位整型 (0 到 255)
  + uint16：无符号 16 位整型 (0 到 65535)
  + uint32：无符号 32 位整型 (0 到 4294967295)
  + uint64：无符号 64 位整型 (0 到 18446744073709551615)
  + int：与 uint 一样大小
  + int8：有符号 8 位整型 (-128 到 127)
  + int16：有符号 16 位整型 (-32768 到 32767)
  + int32：有符号 32 位整型 (-2147483648 到 2147483647)
  + int64：有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)
  + uintptr：无符号整型，用于存放一个指针
  + float32：IEEE-754 32位浮点型数
  + float64：IEEE-754 64位浮点型数
  + complex64：32 位实数和虚数
  + complex128：64 位实数和虚数
  + byte：类似 uint8
  + rune：类似 int32

**字符串类型**

+ 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。

**派生类型**

+ （a） 指针类型（pointer）

+ (b) 数组类型（array）
+ （c）结构化类型（struct）
+ （d) 通道类型（channel）
+ （e） 函数类型（func）
+ （f) 切片类型（slice）
+ （g）接口类型（interface）
+ (h) Map类型(map)
+ (a) 指针类型（pointer） 

## **数字**

### 整形：　　　　

| 类型和描述                                                   | 大小（字节） | 对应Java类型 |
| ------------------------------------------------------------ | ------------ | ------------ |
| **uint8** 无符号 8 位整型 (0 到 255)                         | **1**        | **-**        |
| **uint16** 无符号 16 位整型 (0 到 65535)                     | **2**        | **-**        |
| **uint32** 无符号 32 位整型 (0 到 4294967295)                | **4**        | **-**        |
| **uint64** 无符号 64 位整型 (0 到 18446744073709551615)      | **8**        | **-**        |
| **int8** 有符号 8 位整型 (-128 到 127)                       | **1**        | **byte**     |
| **int16** 有符号 16 位整型 (-32768 到 32767)                 | **2**        | **short**    |
| **int32** 有符号 32 位整型 (-2147483648 到 2147483647)       | **4**        | **int**      |
| **int64** 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) | **8**        | **long**     |

### 浮点型：

| 类型和描述                        |
| --------------------------------- |
| **float32** IEEE-754 32位浮点型数 |
| **float64** IEEE-754 64位浮点型数 |
| **complex64** 32 位实数和虚数     |
| **complex128** 64 位实数和虚数    |

浮点数类型有两个，即float32和float64。存储这两个类型的值的空间分别需要4个字节和8个字节。

浮点数类型的值一般由整数部分、小数点“.”和小数部分组成。其中，整数部分和小数部分均由10进制表示法表示。不过还有另一种表示方法。那就是在其中加入指数部分。指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，3.7E-2表示浮点数0.037。又比如，3.7E+1表示浮点数37。

有时候，浮点数类型值的表示也可以被简化。比如，37.0可以被简化为37。又比如，0.037可以被简化为.037。

有一点需要注意，在Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。比如，03.7表示的一定是浮点数3.7。

在格式化参数中：

●%E 用于以带指数部分的表示法显示浮点数类型值

●%f 用于以通常的方法显示浮点数类型值

### 其他类型：

| 类型和描述                               |
| ---------------------------------------- |
| **byte** type byte = uint8               |
| **rune** type rune = int32               |
| **uintptr** 无符号整型，用于存放一个指针 |
| 复数                                     |

#### 进制

●十进制数表示方法： num := 12 ，格式化参数使用 %d 表示

●八进制数表示方法： num := 014

●十六进制数表示方法： num := 0xC ，格式化参数使用 %x 表示

#### 复数

复数类型同样有两个，即complex64和complex128。存储这两个类型的值的空间分别需要8个字节和16个字节。实际上，complex64类型的值会由两个float32类型的值分别表示复数的实数部分和虚数部分。而complex128类型的值会由两个float64类型的值分别表示复数的实数部分和虚数部分。

复数类型的值一般由浮点数表示的实数部分、加号“+”、浮点数表示的虚数部分，以及小写字母“i”组成。比如，3.7E+1 + 5.98E-2i。正因为复数类型的值由两个浮点数类型值组成，所以其表示法的规则自然需遵从浮点数类型的值表示法的相关规则。

举例：

```go
num := 3.7E+1 + 5.98E-2i
fmt.Println(num) // (37+0.0598i)
```

在格式化参数中，复数仍然可以用 %E 和 %f 表示。

#### byte和rune

 byte与rune类型有一个共性，即：

+  它们都属于别名类型
   + byte是uint8的别名类型
   + rune则是int32的别名类型

byte类型的值需用8个比特位表示，其表示法与uint8类型无异。

一个rune类型的值即可表示一个Unicode字符。Unicode是一个可以表示世界范围内的绝大部分字符的编码规范。详细信息可以参看：http://unicode.org/，https://unicode-table.com/cn/。用于代表Unicode字符的编码值也被称为Unicode代码点。一个Unicode代码点通常由“U+”和一个以十六进制表示法表示的整数表示。例如，英文字母“A”的Unicode代码点为“U+0041”。

rune类型的值需要由单引号“'”包裹。例如，'A'或'昱'。这种表示方法一目了然。不过，我们还可以用另外几种形式表示rune类型值。见下表。  

<img src="%E5%9F%BA%E7%A1%80.assets/image-20231113214158015.png" style="zoom:80%;" />

在rune类型值的表示中支持几种特殊的字符序列，即：转义符。它们由“\”和一个单个英文字符组成。如下表所示。

<img src="%E5%9F%BA%E7%A1%80.assets/image-20231113214220627.png" style="zoom:67%;" />

举例：

```go
var char rune = '昱'
fmt.Printf("字符 %c 的 unicode 为 %x", char, char) // 字符 昱 的 unicode 为 6631
```

这意味着可以这样输出这个汉字：

```go
fmt.Printf("\u6631 is %x", '昱') // 昱 is 6631

if '\u6631' == '昱' {
    fmt.Println(1)
}
```

# 控制流程

### 一、条件语句

#### **if...else**

```go
 var a int = 10

  if a < 0 {
    fmt.Printf("a < 0" )
  } else if a > 0 {
    fmt.Printf("a > 0" )
  } else {
    fmt.Println("a == 0")
  }

if r := getGoodsListRsp.ErrorResponse; r.ErrorCode != 0 {}
```

#### **switch**

<span style="color:red">go的switch语句不需要添加break</span>

##### 普通用法

```go
  var grade string
  var marks int = 90

  switch marks {
    case 90: grade = "A"
    case 80: grade = "B"
    case 50,60,70 : grade = "C"
    default: grade = "D"
  }


    gradel := "B"
    switch gradel {
        case "A":
        fmt.Println("优秀")
        case "B":
        fmt.Println("良好")
        case "C":
        fmt.Println("中等")
        case "D":
        fmt.Println("及格")
        default:
        fmt.Println("不及格")
    }


  switch {
    case grade == "A":
      fmt.Printf("优秀!\n" )
    case grade == "B", grade == "C":
      fmt.Printf("良好\n" )
    case grade == "D":
      fmt.Printf("及格\n" )
    case grade == "F":
      fmt.Printf("不及格\n" )
    default:
      fmt.Printf("差\n" )
  }
  fmt.Printf("你的等级是 %s\n", grade )
```

##### **Type Switch**

switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。

Type Switch 语法格式如下：

```go
switch x.(type){
    case type:
       statement(s);      
    case type:
       statement(s); 
    /* 你可以定义任意个数的case */
    default: /* 可选 */
       statement(s);
}
```

示例：

```go
  var x interface{}

  switch i := x.(type) {
    case nil:
      fmt.Printf(" x 的类型 :%T",i)
    case int:
      fmt.Printf("x 是 int 型")
    case float64:
      fmt.Printf("x 是 float64 型")
    case func(int) float64:
      fmt.Printf("x 是 func(int) 型")
    case bool, string:
      fmt.Printf("x 是 bool 或 string 型" )
    default:
      fmt.Printf("未知型")
  }
```

输出：

```
 x 的类型 :<nil>
```

##### fallthrough

使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。
示例：

```go
  var num = 50
  switch {
    case num > 10:
      fmt.Println("num > 10")
      fallthrough
    case num > 50:
      fmt.Println("num > 50")
      fallthrough
    default:
      fmt.Println("num <= 10")
  }
```

输出：

```
num > 10
num > 50
num <= 10
```

#### **select**

```go
// 定义多个通道
var chanInt chan int = make(chan int, 3)
var chanSting chan string = make(chan string)
var chanBool chan bool = make(chan bool)

func main() {
	go send()
	go receive()
	time.Sleep(time.Second * 10)
	chanSting <- "send over"
	chanBool <- true
}

// 向通道发送数据
func send() {
	time.Sleep(time.Second)
	chanInt <- 1
	time.Sleep(time.Second)
	chanInt <- 2
	time.Sleep(time.Second)
	chanInt <- 3
}

// 获取通道中的数据
func receive() {
	for {
		select {
			case num := <- chanInt:
				fmt.Println(num)
			case str := <- chanSting:
				fmt.Println(str)
			case <- chanBool:
				fmt.Println("运行结束")
            default:
                fmt.Println("unknown channel")
		}
	}
}
```

输出：

```go
1
2
3
send over
运行结束
```

### 二、循环语句

#### 循环数字

```go
//var sum int = 0;
sum := 0
for i := 0; i <= 10; i++ {
    sum += i
}
fmt.Println(sum)
```

#### 循环数组

如果指定了数组长度，而初始化时并未完全填充，则未填充的值为零值

```go
numbers := [6]int{1, 2, 3, 4}
for i, x:= range numbers {
    fmt.Printf("第 %d 位 x 的值 = %d\n", i, x)
}
```

输出

```
第 0 位 x 的值 = 1
第 1 位 x 的值 = 2
第 2 位 x 的值 = 3
第 3 位 x 的值 = 4
第 4 位 x 的值 = 0
第 5 位 x 的值 = 0
```

#### **循环Map**

```go
oldMap := map[int]string{1: "a", 2: "b"}
newMap := map[interface{}]interface{}{}
for key, value := range oldMap {
    newMap[key] = value
}
fmt.Println(newMap) // map[1:a 2:b]
```

```go
// 定义Map
paramMap := make(map[string]string)
// 插入键值对
paramMap["name"] = "yangyongjie"

// 只遍历 key
for key := range paramMap {
	fmt.Println(key, paramMap[key])
}
// 遍历key，value
for key, value := range paramMap {
	fmt.Println(key, value)
}
// 只遍历value
for _, value := range paramMap {
	fmt.Println(value)
}
```



#### **类while循环**

```go
sum := 1
for ; sum <= 10; {
    sum += sum
}
fmt.Println(sum)
```

```go
for sum <= 10{
    sum += sum
}
fmt.Println(sum)
```

#### **无限循环**

```go
for {
    fmt.Println("done")
}
```

```go
for true{
    fmt.Println("done")
}
```

#### **循环控制语句**

循环控制语句包括：

+ break
+ continue  是跳过当次循环中剩下的语句，执行下一次循环。
+ goto

break 和 continue 不多说，重点说一下 goto 。
每一个语句都能对其添加标签，goto用于跳到指定标签处。

```go
/* 定义局部变量 */
var a int = 10

/* 循环 */
LOOP: for a < 20 {
    if a > 12 && a < 18 {
        /* 跳过迭代 */
        a = a + 1
        goto LOOP
    }
    fmt.Printf("a的值为 : %d\n", a)
    a++
}
```

```
a的值为 : 10
a的值为 : 11
a的值为 : 12
a的值为 : 18
a的值为 : 19
```

```go
/* 定义局部变量 */
var a int = 10

/* 循环 */
for a < 20 {
    if a > 12 {
        /* 跳过迭代 */
        a = a + 1
        goto DONE
    }
    fmt.Printf("a的值为 : %d\n", a)
    a++
}

DONE: fmt.Println("done")
```

```
a的值为 : 10
a的值为 : 11
a的值为 : 12
done
```
