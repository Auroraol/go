# **接口**

> **接口（interface，相当于Java中的接口，接口名称首字母大写）**

## 1）接口定义

```go
type Behavior interface {
	Eat() string
	Run() string
}
```

## 2）实现接口

在go中不需要像Java一样使用implements关键字来实现接口，只需要保证struct中的实现的方法传入的参数类型、数量、返回值类型一致即可。

Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。

```go
func (struct_name_variable struct_name) method1() [return_type] {
    // 方法实现
}
```

接口的实现条件：

1. 接口的方法与实现接口的类型方法格式一致
2. 接口中所有方法均被实现

**示例:**

```go
// 定义接口
type Animal interface {
	Grow()
	Move(string) string
}

// 定义结构体
type Cat struct {
	Name string
	Age int
	Place string
}

func (cat *Cat) Grow() {

}

func (cat *Cat) Move(str string) string {
	return ""
}

func main() {
	cat := Cat{"Kitty", 2, "House"}
	animal, ok := interface{}(&cat).(Animal)
	fmt.Printf("%v, %v \n", ok, animal) // true, &{Kitty 2 House}
}
```

　　　 

　　　　3）需要注意：

　　　　　　空接口可以作为任何类型数据的容器

　　　　　　一个类型可实现多个接口

　　　　　　接口命名习惯以 er 结尾

　　　　　　接口只有方法声明，没有实现，没有数据字段

　　　　　　当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问

　　　　　　 接口也可实现类似OOP中的多态

　　　　　　只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗

## 3）接口嵌套

接口与接口间可以通过嵌套创造出新的接口

需要注意的是，嵌入其他接口类型不能有同名方法，也不能嵌入自身或循环嵌入

```go
// Sayer 接口
type Sayer interface {
    say()
}

// Mover 接口
type Mover interface {
    move()
}

// 接口嵌套
type animal interface {
    Sayer
    Mover
}
```

## 4）通过接口实现多态

```go
package main

import "fmt"

//本质是一个指针
type AnimalIF interface {
	Sleep()
	GetColor() string //获取动物的颜色
	GetType() string  //获取动物的种类
}

//具体的类
type Cat struct {
	color string //猫的颜色
}

func (this *Cat) Sleep() {
	fmt.Println("Cat is Sleep")
}

func (this *Cat) GetColor() string {
	return this.color
}

func (this *Cat) GetType() string {
	return "Cat"
}

//具体的类
type Dog struct {
	color string
}

func (this *Dog) Sleep() {
	fmt.Println("Dog is Sleep")
}

func (this *Dog) GetColor() string {
	return this.color
}

func (this *Dog) GetType() string {
	return "Dog"
}

func showAnimal(animal AnimalIF) {
	animal.Sleep() //多态
	fmt.Println("color = ", animal.GetColor())
	fmt.Println("kind = ", animal.GetType())
}

func main() {

	var animal AnimalIF //接口的数据类型， 父类指针
	animal = &Cat{"Green"}

	animal.Sleep() //调用的就是Cat的Sleep()方法 , 多态的现象

	animal = &Dog{"Yellow"}

	animal.Sleep() // 调用Dog的Sleep方法，多态的现象

	cat := Cat{"Green"}
	dog := Dog{"Yellow"}

	showAnimal(&cat)
	showAnimal(&dog)
}
```

## 5）空接口（interface{}）

**使用技巧**

①：尽量定义包含方法少的接口，建议控制接口方法数量不超过 3 个

+ 可以在一些 Golang 语言标准库中发现，很多接口包含的方法数量都不超过 3 个，也有很多接口仅包含 1 个方法
+ 控制接口包含方法的数量尽量少的好处是接口包含的方法越少，越容易实现和组合

②：尽量不使用空接口类型作为函数参数

+ Golang 语言是强类型静态语言，Golang 编译器在编译期间会对变量做类型检查。如果函数或方法接收的参数类型是空接口 interface{}，编译器将收不到任何信息，也就不会对空接口类型的变量进行类型检查，接收参数的类型将需要开发者自己做类型检查。所以开发者尽量不要使用空接口 interface{} 变量作为接收参数
+ 但是空接口 interface{} 类型也并非完全无用武之地，因为目前 Golang 语言（v1.16.4）还未支持泛型，当需要处理未知类型的参数时，可以使用空接口 interface{} 类型，在 Golang 语言标准库中也有该使用方式，比如 fmt 包

### 应用

空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口，空接口可以存储任意类型的值。

空接口应用：

1. 空接口作为函数的参数:  使用空接口实现可以接收任意类型的函数参数

   ```go
   // 空接口作为函数参数
   func show(a interface{}) {
   ...
   }
   ```

2. 空接口作为map的值: map使用空接口可以保存任意类型的值

   ```go
   // 空接口作为map值
   var studentInfo = make(map[string]interface{})
   studentInfo["name"] = "李白"
   studentInfo["age"] = 18
   studentInfo["married"] = false
   fmt.Println(studentInfo)
   ```

### 类型断言

一个接口类型的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。

这两部分分别称为接口的动态类型和动态值

想要判断空接口中的值的动态类型是否满足指定的类型可以使用类型断言，语法格式为：

```go
 x.(T)
//x：表示类型为interface{}的变量
//T：表示断言x可能是的类型。
```

**示例:**

```go
func main() {
    var x interface{}
    x = "pprof.cn"
    v, ok := x.(string)
    if ok {
        fmt.Println(v)
    } else {
        fmt.Println("类型断言失败")
    }
}
```