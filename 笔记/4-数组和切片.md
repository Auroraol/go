# 数组

**声明**

```go
var var_name [size] var_type 
//如：
var a [10] int32
```

**声明并初始化**

```go
var a = [5] int{1,2,3,4,5}
//初始化数组中 {} 中的元素个数不能大于 [] 中的数字
```

+ 如果数组长度不固定，可以使用 ... 代替，编译期会根据元素个数自行推断数组的长度，如: var arr = [...]int{1, 2, 3, 4, 5}

+ 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小

**访问**

```go
//根据索引（从0开始）来读取值：
var ar = arr[2]
```

**向函数传递数组**　

```go
//值
void myFunction(param []int)
{...}

//指针
void myFunction(param *[]int)
{...}
```

# 切片

Go语言切片是对数组的抽象（一般使用切片代替数组就行了）Slice，"动态数组"

## 切片声明

### 1. 方法1

```go
// 声明字符串切片 为nil的
var 切片名称 [] 切片类型
// 声明一个空切片 为{}
var 切片名称 = []切片类型{}
```

**示例:**

```go
var numList []int // 创建一个nil切片
numListEmpty := []int{} // 创建一个空的整型切片
```

### 2.  方法2: make() 已知存储的元素数量时  [推荐]

```go
切片名称 := make([]切片类型, 长度, 指定容量(可选))
```

**示例:**

```go
numbers := make([]int, 5, 10)
```

## **初始化**

**声明并初始化**

```go
lice1 := []int{1, 2, 3, 4, 5}
```

**从指定范围中初始化**

```go
var highRiseBuilding [20]int

//
for i := 0; i < 20; i++ {
	highRiseBuilding[i] = i + 1
}

// 区间 [11 12 13 14 15]
fmt.Println(highRiseBuilding[10:15])
// 中间到尾部的所有元素 [11 12 13 14 15 16 17 18 19 20]
fmt.Println(highRiseBuilding[10:])
// 开头到中间指定位置的所有元素 [1 2]
fmt.Println(highRiseBuilding[:2])
 
//输出所有元素
a := []int{1, 2, 3}
fmt.Println(a[:]) //[1 2 3]
 
a := []int{1, 2, 3}
fmt.Println(a[0:0]) //输出为0
```

## 切片内置函数

+ len()：获取切片长度
+ cap()：获取切片最大可达长度

+ append() 通过append追加值，默认只能值传递。
+ copy()：拷贝另一个切片的元素

````go
slice1 := []int{1, 2, 3, 4, 5}
slice2 := []int{5, 4, 3}
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
fmt.Println(slice2)  //[1 2 3]
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置
fmt.Println(slice1) //[1 2 3 4 5]
````

## 切片截取

可以通过设置下限及上限来设置截取切片 [lower-bound:upper-bound]

```go
 /* 创建切片 */
numbers := []int{0,1,2,3,4,5,6,7,8}  
// 截取切片从索引1(包含) 到索引4(不包含)
numbers[1:4]
// 默认下限为0
numbers[:3]
// 默认上限为len(s)
numbers[4:]
```

## 对切片数据排序　

```go
s := []int{1, 2, 3, 6, 7, 9, 3}
// sort.Ints对整数进行排序，sort.Strings对字符串进行排序，sort.Float64s对浮点数进行排序,sort.Sort对接口类型排序
sort.Ints(s)
for _, v := range s {
    fmt.Print(v) // 1233679
}
```

## 切片遍历

```go
s := []string{"beijing", "shanghai", "guangzhou", "shenzheng"}
    
// 普通for循环遍历
for i:=0;i<len(s);i++{
    fmt.Printf(s[i])
}
// range循环遍历
for i, v := range s {
    fmt.Printf("索引 %d 的值 = %s\n", i, v)
}
```

## 作为函数参数

```go
package main

import "fmt"

// 定义一个接受切片作为参数的函数
func modifySlice(s []int) {
    for i := range s {
        s[i] *= 2 // 将每个元素乘以2
    }
}

func main() {
    // 创建一个整型切片
    numbers := []int{1, 2, 3, 4, 5}

    // 打印修改前的切片
    fmt.Println("修改前:", numbers)

    // 调用函数修改切片
    modifySlice(numbers)

    // 打印修改后的切片
    fmt.Println("修改后:", numbers)
}
```

运行结果

```
修改前: [1 2 3 4 5]
修改后: [2 4 6 8 10]
```