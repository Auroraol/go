# **接口**

> **接口（interface，相当于Java中的接口，接口名称首字母大写）**

## 1）接口定义

```go
type 接口类型名 interface {
	方法名1(参数列表) 返回值列表
	方法名2(参数列表) 返回值列表
	...
}
```

## 2）实现接口

在go中不需要像Java一样使用implements关键字来实现接口，只需要保证struct中的实现的方法传入的参数类型、数量、返回值类型一致即可。

Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。

```go
func (struct_name_variable struct_name) method1() [return_type] {
    // 方法实现
}
```

接口的实现条件：

1. 接口的方法与实现接口的类型方法格式一致
2. 接口中所有方法均被实现

**示例:**

```go
package main

import "fmt"

// 运输方式
type Transporter interface {
	BicycleTran()
	CarTran()
}

// 驾驶员
type Driver struct {
	Name string
	Age  int
}

// 实现运输方式接口
func (d *Driver) BicycleTran() {
	fmt.Println("使用自行车运输")
}
func (d *Driver) CarTran() {
	fmt.Println("使用小汽车运输")
}

func main() {
	d := &Driver{
		"张三",
		27,
	}
	trans(d)
}

// 只要实现了 Transporter接口的类型都可以作为参数
func trans(t Transporter) {
	t.BicycleTran()
}
```

注意：

- Go语言的接口在命名时，一般会在单词后面添加er，如写操作的接口叫做Writer
- 当方法名首字母大写，且实现的接口首字母也是大写，则该方法可以被接口所在包之外的代码访问
- 方法与接口中的方法签名一致（方法名、参数列表、返回列表都必须一致）
- 参数列表和返回值列表中的变量名可以被忽略，如：type writer interfae{ Write([]byte) error}
- 接口中所有的方法都必须被实现
- 如果编译时发现实现接口的方法签名不一致，则会报错：` does not implement `。  

## 3）接口嵌套

接口与接口间可以通过嵌套创造出新的接口

注意: 嵌入其他接口类型不能有同名方法，也不能嵌入自身或循环嵌入

```go
// 定义一个 写 接口
type Writer interface {
	Write(p []byte) (n int, e error)
}

// 定义一个 读 接口
type Reader interface {
	Read() error
}

// 定义一个 嵌套接口
type IO interface {
	Writer
	Closer
}
```

## 4）空接口（interface{}）

**使用技巧**

①：尽量定义包含方法少的接口，建议控制接口方法数量不超过 3 个

+ 可以在一些 Golang 语言标准库中发现，很多接口包含的方法数量都不超过 3 个，也有很多接口仅包含 1 个方法
+ 控制接口包含方法的数量尽量少的好处是接口包含的方法越少，越容易实现和组合

②：尽量不使用空接口类型作为函数参数

+ Golang 语言是强类型静态语言，Golang 编译器在编译期间会对变量做类型检查。如果函数或方法接收的参数类型是空接口 interface{}，编译器将收不到任何信息，也就不会对空接口类型的变量进行类型检查，接收参数的类型将需要开发者自己做类型检查。所以开发者尽量不要使用空接口 interface{} 变量作为接收参数
+ 但是空接口 interface{} 类型也并非完全无用武之地，因为目前 Golang 语言（v1.16.4）还未支持泛型，当需要处理未知类型的参数时，可以使用空接口 interface{} 类型，在 Golang 语言标准库中也有该使用方式，比如 fmt 包

### 基本使用

#### 空接口定义

空接口是接口的特殊形式，没有任何方法，因此任何具体的类型都可以认为实现了空接口。

```go
	var any interface{}

	any = 1
	fmt.Println(any)

	any = "hello"
	fmt.Println(any)
```

空接口作为函数参数：

```go
func Test(i interface{}) {
	fmt.Printf("%T\n", i)
}

func main() {
	Test(3)			// int
	Test("hello")	// sting
}
```

利用空接口，可以实现任意类型的存储：

```go
	m := make(map[string]interface{})
	m["name"] = "李四"
	m["age"] = 30	
```

#### 从空接口获取值

保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误：

```go
	var a int = 1
	var i interface{} = a
	var b int = i				//这里编译报错（类型不一致），可以这样做：b := i
```

#### 空接口值比较

类型不同的空接口比较：

```go
	var a interface{} = 100
	var b interface{} = "hi"

	fmt.Println(a == b)			//false
```

不能比较空接口中的动态值：

```go
	var c interface{} = []int{10}
	var d interface{} = []int{20}
	fmt.Println(c == d)					//运行报错
```

空接口的类型和可比较性：

| 类型   | 说明                                               |
| ------ | -------------------------------------------------- |
| map    | 不可比较，会发生宕机错误                           |
| 切片   | 不可比较，会发生宕机错误                           |
| 通道   | 可比较，必须由同一个make生成，即同一个通道才是true |
| 数组   | 可比较，编译期即可知道是否一致                     |
| 结构体 | 可比较，可逐个比较结构体的值                       |
| 函数   | 可比较                                             |

### 应用

空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口，空接口可以存储任意类型的值。

空接口应用：

1. 空接口作为函数的参数:  使用空接口实现可以接收任意类型的函数参数

   ```go
   // 空接口作为函数参数
   func show(a interface{}) {
   ...
   }
   ```

2. 空接口作为map的值: map使用空接口可以保存任意类型的值

   ```go
   // 空接口作为map值
   var studentInfo = make(map[string]interface{})
   studentInfo["name"] = "李白"
   studentInfo["age"] = 18
   studentInfo["married"] = false
   fmt.Println(studentInfo)
   ```

### 类型断言

一个接口类型的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。

这两部分分别称为接口的动态类型和动态值

想要判断空接口中的值的动态类型是否满足指定的类型可以使用类型断言，语法格式为：

```go
 x.(T)
//x：表示类型为interface{}的变量
//T：表示断言x可能是的类型。
```

**示例:**

```go
func main() {
    var x interface{}
    x = "pprof.cn"
    v, ok := x.(string)
    if ok {
        fmt.Println(v)
    } else {
        fmt.Println("类型断言失败")
    }
}
```

## 5）接收器与接口结合使用规则

```go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}   //实现接口,  值方法集


type S2 struct{}

func (s *S2) f() {}   //实现接口, 指针方法集

// 
s1Val := S1{}   
s1Ptr := &S1{}  

s2Val := S2{}
s2Ptr := &S2{}

var i F

//值方法集
i = s1Val
i = s1Ptr

//指针方法集 //只能将指针对象赋值给接口变量
i = s2Ptr   

//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器
//   i = s2Val
```

接口的匹配 (或者叫实现) 具体的匹配分两种：

- 值方法集和接口匹配:  都行  
- 指针方法集和接口匹配 
  - 只能将指针对象赋值给接口变量，因为只有指针方法集和接口匹配

总结:  实现时用的指针就必须是指针对象

## 6）断言与多态

### 一 断言

接口是编程的规范，他也可以作为函数的参数，以让函数更具备适用性。在下列示例中，有三个接口动物接口、飞翔接口、游泳接口，两个实现类鸟类与鱼类：

- 鸟类：实现了动物接口，飞翔接口
- 鱼类：实现了动物接口，游泳接口

```go
package main

import "fmt"

// 定义一个通用接口：动物接口
type Animal interface {
	Breath()	// 动物都具备 呼吸方法
}

type Flyer interface {
	Fly()
}
type Swimer interface {
	Swim()
}

// 定义一个鸟类：其呼吸的方式是在陆地
type Bird struct {
	Name string
	Food string
	Kind string
}
func (b *Bird) Breath() {
	fmt.Println("鸟 在 陆地 呼吸")
}
func (b *Bird) Fly() {
	fmt.Printf("%s 在 飞\n", b.Name)
}

// 定义一个鱼类：其呼吸方式是在水下
type Fish struct {
	Name string
	Kind string
}
func (f *Fish) Breath() {
	fmt.Println("鱼 在 水下 呼吸")
}
func (f *Fish) Swim() {
	fmt.Printf("%s 在游泳\n", f.Name)
}

// 一个普通函数，参数是动物接口
func Display(a Animal) {
	// 直接调用接口中的方法
	a.Breath()
	// 调用实现类的成员：此时会报错
	fmt.Println(a.Name)
}

func main() {
	var b = &Bird{
		"斑鸠",
		"蚂蚱",
		"鸟类"
	}
	Display(b)
}
```

接口类型无法直接访问其具体实现类的成员，需要使用断言（type assertions），对接口的类型进行判断，类型断言格式：

```go
t := i.(T)			//不安全写法：如果i没有完全实现T接口的方法，这个语句将会触发宕机
t, ok := i.(T)		// 安全写法：如果接口未实现接口，将会把ok掷为false，t掷为T类型的0值
```

- i代表接口变量
- T代表转换的目标类型
- t代表转换后的变量


上述案例的Dsiplay就可以书写为：

```go
func Display(a Animal) {
	// 直接调用接口中的方法
	a.Breath()
	// 调用实现类的成员：此时会报错
	instance, ok := a.(*Bird)	// 注意：这里必须是 *Bird类型，因为是*Bird实现了接口，不是Bird实现了接口
	if ok {
		// 得到了具体的实现类，才能访问实现类的成员
		fmt.Println("该鸟类的名字是：", instance.Name)
	} else {
		fmt.Println("该动物不是鸟类")
	}
}
```

### 二 接口类型转换

在接口定义时，其类型已经确定，因为接口的本质是方法签名的集合，如果两个接口的方法签名集合相同（顺序可以不同），则这2个接口之间不需要强制类型转换就可以相互赋值，因为go编译器在校验接口是否能赋值时，比较的是二者的方法集。  

在上一节中，函数Display接收的是Animal接口类型，在断言后转换为了别的类型：*Bird(实现类指针类型)：

```go
func Display(a Animal) {
	instance, ok := a.(*Bird)		// 动物接口转换为了 *Bird实现类
	if ok {
		// 得到了具体的实现类，才能访问实现类的成员
		fmt.Println("该鸟类的名字是：", instance.Name)
	} else {
		fmt.Println("该动物不是鸟类")
	}
}
```

其实，断言还可以将接口转换成另外一个接口：

```go
func Display(a Animal) {
	instance, ok := a.(Flyer)			// 动物接口转换为了飞翔接口
	if ok {
		instance.Fly()
	} else {
		fmt.Println("该动物不会飞")
	}

}
```

一个实现类往往实现了很多接口，为了精准类型查询，可以使用switch语句来判断对象类型：

```go
var v1 interfaceP{} = ...
switch v := v1.(type) {
	case int:
	case string:
	...
}
```

### 三 多态

**示例1:**

```go
// New出Animal的函数
func NewAnimal(kind string) Animal{

	switch kind {
	case "鸟类":
		return &Bird{}
	case "鱼类":
		return &Fish{}
	default:
		return nil
	}

}

func main() {
	// 获取的是动物接口类型，但是实现类是鸟类
	a1 := NewAnimal("鸟类")
	a1.Breath()		// 鸟 在 陆地 呼吸

	// 获取的是动物接口类型，但是实现类是鱼类
	a2 := NewAnimal("鱼类")
	a2.Breath()		// 鱼 在 水下 呼吸
}
```

**示例2:**

```go
package main

import "fmt"

//本质是一个指针
type AnimalIF interface {
	Sleep()
	GetColor() string //获取动物的颜色
	GetType() string  //获取动物的种类
}

//具体的类
type Cat struct {
	color string //猫的颜色
}

func (this *Cat) Sleep() {
	fmt.Println("Cat is Sleep")
}

func (this *Cat) GetColor() string {
	return this.color
}

func (this *Cat) GetType() string {
	return "Cat"
}

//具体的类
type Dog struct {
	color string
}

func (this *Dog) Sleep() {
	fmt.Println("Dog is Sleep")
}

func (this *Dog) GetColor() string {
	return this.color
}

func (this *Dog) GetType() string {
	return "Dog"
}

func showAnimal(animal AnimalIF) {
	animal.Sleep() //多态
	fmt.Println("color = ", animal.GetColor())
	fmt.Println("kind = ", animal.GetType())
}

func main() {

	var animal AnimalIF //接口的数据类型， 父类指针
	animal = &Cat{"Green"}

	animal.Sleep() //调用的就是Cat的Sleep()方法 , 多态的现象

	animal = &Dog{"Yellow"}

	animal.Sleep() // 调用Dog的Sleep方法，多态的现象

	cat := Cat{"Green"}
	dog := Dog{"Yellow"}

	showAnimal(&cat)
	showAnimal(&dog)
}
```
