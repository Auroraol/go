## 一 切片

Go语言切片是对数组的抽象（一般使用切片代替数组）Slice，"动态数组"

声明数组时，方括号内写明了数组的长度或使用...自动计算长度，而声明slice时，方括号内没有任何字符。  

## 二 切片声明

### 1. 方法1

```go
// 声明字符串切片 为nil的
var 切片名称 [] 切片类型
// 声明一个空切片 为{}
var 切片名称 = []切片类型{}
```

**示例:**

```go
var numList []int // 创建一个nil切片
numListEmpty := []int{} // 创建一个空的整型切片

fmt.Println(s1)				//输出 []
fmt.Print(s2)				//输出 [97 98 99]
```

### 2.  方法2: make() 已知存储的元素数量时  [推荐]

```go
切片名称 := make([]切片类型, 长度, 指定容量(可选))
```

**示例:**

```go
slice1 := make([]int,5)		// 创建长度为5，容量为5，初始值为0的切片
slice2 := make([]int,5,7)	// 创建长度为5，容量为7，初始值为0的切片
```

## 三 初始化

**声明并初始化**

```go
lice1 := []int{1, 2, 3, 4, 5}
```

**从指定范围中初始化**

```go
var highRiseBuilding [20]int  // 数组

for i := 0; i < 20; i++ {
	highRiseBuilding[i] = i + 1
}

// 区间 [11 12 13 14 15]
fmt.Println(highRiseBuilding[10:15])
// 中间到尾部的所有元素 [11 12 13 14 15 16 17 18 19 20]
fmt.Println(highRiseBuilding[10:])
// 开头到中间指定位置的所有元素 [1 2]
fmt.Println(highRiseBuilding[:2])
 
//输出所有元素
a := []int{1, 2, 3}
fmt.Println(a[:]) //[1 2 3]
 
a := []int{1, 2, 3}
fmt.Println(a[0:0]) //输出为0
```


## 二 切片常见操作

#### 2.1 切片常见内置函数

切片常用内置函数：
```
len()			返回切片长度
cap()			返回切片底层数组容量
append()		对切片追加元素，默认只能值传递
func copy(dst, src []Type) int
				将src中数据拷贝到dst中，返回拷贝的元素个数
```

切片空间与元素个数：
```go
slice1 := make([]int, 5, 10)
fmt.Println(len(slice1))			// 5
fmt.Println(cap(slice1))			// 10
fmt.Println(slice1)					// [0 0 0 0 0]
```

切片操作
```go
//切片增加
slice1 = append(slice1,1,2)
fmt.Println(slice1)						//输出[0 0 0 0 0 1 2]

//切片增加一个新切片
sliceTemp := make([]int,3)
slice1 = append(slice1,sliceTemp...)
fmt.Println(slice1)						//输出[0 0 0 0 0 1 2 0 0 0]

//切片拷贝
s1 := []int{1,3,6,9}
s2 := make([]int, 10)	//必须给与充足的空间
num := copy(s2, s1)

fmt.Println(s1)			//[1 3 6 9]
fmt.Println(s2)			//[1 3 6 9 0 0 0 0 0 0]
fmt.Println(num)		//4

//切片中删除元素
s1 := []int{1,3,6,9}
index := 2					//删除该位置元素
s1 = append(s1[:index], s1[index+1:]...)
fmt.Println(s1)				//[1 3 9]

// 切片拷贝
s1 := []int{1,2,3,4,5}
s2 := []int{6,7,8}
copy(s1,s2) 				//复制s2前三个元素到slice1前3位置
copy(s2,s1)	 				//复制s1前三个元素到slice2
```
注意：没有...会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。  

#### 2.2 切片的一些简便操作  

- slice的默认开始位置是0，ar[:n]等价于ar[0:n]
- slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]
- 如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]
- 切片的遍历可以使用for循环，也可以使用range函数  

```go
// 声明一个数组
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 声明两个slice
var aSlice, bSlice []byte

// 演示一些简便操作
aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c
aSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j
aSlice = array[:] // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素

// 从slice中获取slice
aSlice = array[3:7] // aSlice包含元素: d,e,f,g，len=4，cap=7
bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f
bSlice = aSlice[:3] // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f
bSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h
bSlice = aSlice[:] // bSlice包含所有aSlice的元素: d,e,f,g
```

#### 2.3 切片的截取

- `s[n]`：切片s中索引为位置为n的项
- `s[:]`：从切片s的索引位置0到`len(s)-1`所获得的切片
- `s[low:]`：从切片s的索引位置low到`len(s)-1`所获得的切片
- `s[:high]`：从切片s的索引位置0到high所获得的切片
- `s[low:high]`：从切片s的索引位置low到high所获得的切片
- `s[low:high:max]`：从low到high的切片，且容量`cap=max-low`

```go
 /* 创建切片 */
numbers := []int{0,1,2,3,4,5,6,7,8}  
// 截取切片从索引1(包含) 到索引4(不包含)
numbers[1:4]
// 默认下限为0
numbers[:3]
// 默认上限为len(s)
numbers[4:]
```

#### 2.4 字符串转切片  

```go
str := "hello,世界"
a := []byte(str)		//字符串转换为[]byte类型切片
b := []rune(str)		//字符串转换为[]rune类型切片
```

#### 2.5 对切片数据排序　

```go
s := []int{1, 2, 3, 6, 7, 9, 3}
// sort.Ints对整数进行排序，sort.Strings对字符串进行排序，sort.Float64s对浮点数进行排序,sort.Sort对接口类型排序
sort.Ints(s)
for _, v := range s {
    fmt.Print(v) // 1233679
}
```

#### 2.6 切片遍历

```go
s := []string{"beijing", "shanghai", "guangzhou", "shenzheng"}
    
// 普通for循环遍历
for i:=0;i<len(s);i++{
    fmt.Printf(s[i])
}
// range循环遍历  // forr
for i, v := range s {
    fmt.Printf("索引 %d 的值 = %s\n", i, v)
}
```

## 三 切片作为函数参数

### 修改切片

```go
func main() {
	var arr = []int{1, 2, 3, 4, 5}
	fmt.Printf("arr pointer: %p\n", &arr)
	test(&arr)
	fmt.Printf("arr: %v\n", arr)
}

func test(data *[]int) {
	fmt.Printf("data pointer: %p\n", data)
	*data = append(*data, 100)
	(*data)[0] = 100
}
```

```
arr pointer: 0xc000116540
data pointer: 0xc000116540
arr: [100 2 3 4 5 100]
```

### 不修改切片

```go
func main() {
	var arr = []int{1, 2, 3, 4, 5}
	fmt.Printf("arr pointer: %p\n", &arr)
	test(arr)
	fmt.Printf("arr: %v\n", arr)
}

func test(data []int) {
	for i, _ := range data {
		data[i] *= 2 // 将每个元素乘以2
	}
}
```

```
arr pointer: 0xc000116540
arr: [2 4 6 8 10]
```

